// Generated by CoffeeScript 1.10.0
(function() {
  'use strict';
  var Logger, Mongo, OplogReader, Sync, _, async,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  async = require('async');

  _ = require('underscore');

  Mongo = require('./mongo');

  Logger = require('./logger');

  OplogReader = require('./oplog_reader');

  Sync = (function() {
    function Sync(config) {
      var base, base1, base2;
      this.config = config;
      this.applyOplog = bind(this.applyOplog, this);
      this.logger = new Logger(this.config.options.loglv);
      this.oplogReader = new OplogReader(this.config);
      (base = this.config.options).targetDB || (base.targetDB = {
        '*': true
      });
      (base1 = this.config.options).syncCommand || (base1.syncCommand = {});
      (base2 = this.config.options).syncIndex || (base2.syncIndex = {});
      this.oplogConfig = _.extend({}, this.config.src, {
        database: 'local',
        collection: 'oplog.rs'
      });
      this.lastConfig = _.extend({
        database: 'mongosync',
        collection: 'last'
      }, this.config.dst);
    }

    Sync.prototype.init = function(done) {
      this.opByNs = {};
      this.oplogReader.init();
      this.lastMongo = new Mongo(this.lastConfig);
      this.replicateCallbacks = [];
      this.replicating = false;
      return done(null);
    };

    Sync.prototype.getTailTS = function(done) {
      return this.oplogReader.getTailTS((function(_this) {
        return function(err, last) {
          if (err) {
            return done(err);
          }
          _this.lastTS = last.ts;
          return done(null, _this.lastTS);
        };
      })(this));
    };

    Sync.prototype.getLastTS = function(done) {
      if (this.config.options.force_tail) {
        return this.getTailTS(done);
      }
      this.logger.verbose('Get lastTS: ', {
        _id: this.config.name
      });
      return this.lastMongo.findOne({
        _id: this.config.name
      }, (function(_this) {
        return function(err, last) {
          if (err) {
            return done(err);
          }
          if (!last) {
            return _this.getTailTS(done);
          }
          _this.lastTS = last.ts;
          return done(null, _this.lastTS);
        };
      })(this));
    };

    Sync.prototype.saveLastTimestamp = function(last, done) {
      if (this.config.options.dryrun) {
        return done(null);
      }
      return this.lastMongo.update({
        _id: this.config.name
      }, {
        $set: {
          ts: last
        }
      }, {
        upsert: true
      }, done);
    };

    Sync.prototype.parseNS = function(ns) {
      var ns_split;
      ns_split = ns.split('\.');
      return {
        db: ns_split.shift(),
        col: ns_split.join('\.')
      };
    };

    Sync.prototype.convertDB = function(logNS) {
      var ns;
      ns = this.parseNS(logNS);
      if (_.isString(this.config.options.targetDB[ns.db])) {
        ns.db = this.config.options.targetDB[ns.db];
        return ns;
      }
      if (this.config.options.targetDB['*']) {
        return ns;
      }
      return null;
    };

    Sync.prototype.getDstMongo = function(ns) {
      if (this.dstMongoByNs[ns]) {
        return this.dstMongoByNs[ns];
      }
      this.dstMongoByNs[ns] = Mongo.getByNS(this.config.dst, ns);
      return this.dstMongoByNs[ns];
    };

    Sync.prototype.applyOplog = function(oplog, repairMode, done) {
      var base, cmd, convertedNS, mongo, ns, o, op, ref, v;
      this.logger.debug('applyOplog', oplog);
      convertedNS = this.convertDB(oplog.ns);
      if (!convertedNS) {
        return done(null);
      }
      ns = convertedNS.db + "." + convertedNS.col;
      if (oplog.op === 'n') {
        this.logger.info('NP', oplog);
        return done(null);
      }
      if (oplog.op === 'i' && convertedNS.col === 'system.indexes') {
        if (this.config.options.syncIndex.create) {
          this.replication((function(_this) {
            return function() {
              return _this.createIndex(convertedNS.db + "." + (_this.parseNS(oplog.o.ns).col), oplog, function(err) {
                return done(err);
              });
            };
          })(this));
        } else {
          this.logger.info('Skip createIndex', oplog.o);
          return done(null);
        }
        return;
      }
      if (oplog.op === 'c') {
        if (oplog.o['deleteIndexes']) {
          if (!this.config.options.syncIndex.drop) {
            this.logger.info('Skip dropIndex', oplog.o);
            return done(null);
          }
          this.logger.info('dropIndex', oplog.o);
        } else {
          o = {};
          ref = oplog.o;
          for (cmd in ref) {
            v = ref[cmd];
            if ((this.config.options.syncCommand[cmd] != null ? this.config.options.syncCommand[cmd] : this.config.options.syncCommand['*'])) {
              o[cmd] = v;
            } else {
              this.logger.info("Skip command {" + cmd + ": " + v + "}");
            }
          }
          oplog.o = o;
          if (_.isEmpty(oplog.o)) {
            return done(null);
          }
        }
        this.replication((function(_this) {
          return function() {
            return _this.runCommand(ns, oplog, function(err) {
              return done(err);
            });
          };
        })(this));
        return;
      }
      (base = this.opByNs)[ns] || (base[ns] = {
        i: 0,
        u: 0,
        d: 0,
        m: 0
      });
      op = this.opByNs[ns];
      if (oplog.fromMigrate) {
        op.m++;
        return done(null);
      }
      mongo = this.getDstMongo(ns);
      return mongo._col((function(_this) {
        return function(err, col) {
          if (err) {
            return done(err);
          }
          if (!repairMode) {
            op.bulk || (op.bulk = col.initializeOrderedBulkOp());
          }
          if (oplog.op === 'i') {
            op.i++;
            if (repairMode) {
              return mongo.insert(oplog.o, function(err) {
                if (err && (err.code = 11000)) {
                  return done(null);
                }
                return done(err);
              });
            } else {
              op.bulk.insert(oplog.o);
              return done(null, oplog);
            }
          }
          if (oplog.op === 'u') {
            op.u++;
            if (oplog.b) {
              if (repairMode) {
                return mongo.update(oplog.o2, oplog.o, {
                  upsert: true
                }, function(err) {
                  return done(err);
                });
              } else {
                op.bulk.find(oplog.o2).upsert().updateOne(oplog.o);
                return done(null, oplog);
              }
            } else {
              if (repairMode) {
                return mongo.update(oplog.o2, oplog.o, {}, function(err) {
                  return done(err);
                });
              } else {
                op.bulk.find(oplog.o2).updateOne(oplog.o);
                return done(null, oplog);
              }
            }
          }
          if (oplog.op === 'd') {
            op.d++;
            if (repairMode) {
              return mongo.removeOne(oplog.o, function(err) {
                return done(err);
              });
            } else {
              op.bulk.find(oplog.o).removeOne();
              return done(null, oplog);
            }
          }
          _this.logger.error('unknown op', oplog);
          throw Error('unknown op');
        };
      })(this));
    };

    Sync.prototype.runCommand = function(ns, oplog, done) {
      var mongo;
      this.logger.info('command', oplog.o);
      if (this.config.options.dryrun) {
        return done(null);
      }
      mongo = Mongo.getByNS(this.config.dst, ns);
      return mongo.init((function(_this) {
        return function(err, db) {
          if (err) {
            return done(err);
          }
          return db.command(oplog.o, function(err) {
            if (err) {
              return done(err);
            }
            return _this.saveLastTimestamp(oplog.ts, done);
          });
        };
      })(this));
    };

    Sync.prototype.createIndex = function(ns, oplog, done) {
      var key, mongo;
      key = oplog.o.key;
      delete oplog.o.key;
      delete oplog.o.ns;
      this.logger.info('createIndex', ns, key, oplog.o);
      if (this.config.options.dryrun) {
        return done(null);
      }
      mongo = Mongo.getByNS(this.config.dst, ns);
      return mongo.createIndex(key, oplog.o, (function(_this) {
        return function(err) {
          if (err) {
            return done(err);
          }
          return _this.saveLastTimestamp(oplog.ts, done);
        };
      })(this));
    };

    Sync.prototype.replication = function(done) {
      var callbacks, last, now, opByNs, oplogs;
      this.logger.trace("replication(): replicating: " + this.replicating + ", numCallbacks: " + this.replicateCallbacks.length + ", opByNs: " + (_.isEmpty(this.opByNs)) + ", logs: " + (this.oplogReader.length()));
      if (this.replicating) {
        this.replicateCallbacks.push(done);
        return;
      }
      if (!this.oplogReader.length()) {
        return done(null);
      }
      this.replicating = true;
      now = Math.floor(Date.now() / 1000);
      this.replicateCallbacks.push(done);
      callbacks = this.replicateCallbacks;
      this.replicateCallbacks = [];
      opByNs = this.opByNs;
      this.opByNs = {};
      oplogs = this.oplogReader.clearLogs();
      last = oplogs[oplogs.length - 1].ts;
      this.logger.info("replication: (" + last.high_ + "," + last.low_ + "): delay: " + (now - last.high_) + " op: " + oplogs.length);
      return async.each(_.keys(opByNs), (function(_this) {
        return function(ns, done) {
          var op;
          op = opByNs[ns];
          _this.logger.verbose(ns + ": i:" + op.i + ", u:" + op.u + ", d:" + op.d + ", m: " + op.m);
          if (_this.config.options.dryrun) {
            return done(null);
          }
          if (!op.bulk) {
            return done(null);
          }
          return op.bulk.execute(done);
        };
      })(this), (function(_this) {
        return function(err) {
          var finish;
          finish = function() {
            return _this.saveLastTimestamp(last, function(err) {
              return async.each(callbacks, function(callback, done) {
                callback(err);
                return done(null);
              }, function() {
                _this.replicating = false;
                if (_.isEmpty(_this.opByNs)) {
                  return setTimeout(function() {
                    return _this.replication(function() {});
                  }, 0);
                }
              });
            });
          };
          if (err) {
            _this.logger.error('@replication error', err);
            if (err.code === 11000) {
              _this.logger.info('Try to repair: logs:', oplogs.length);
              async.eachSeries(oplogs, function(oplog, done) {
                return _this.applyOplog(oplog, true, done);
              }, function(err) {
                if (err) {
                  _this.logger.error('Repair error', err);
                  throw Error('@replication error');
                }
                return finish();
              });
              return;
            } else {
              throw Error('@replication error');
            }
          }
          return finish();
        };
      })(this));
    };

    Sync.prototype.sync = function(done) {
      var bulkCallback, eachCallback;
      this.dstMongoByNs = {};
      eachCallback = (function(_this) {
        return function(oplog, done) {
          return _this.applyOplog(oplog, false, function(err, filteredLog) {
            if (!_this.replicating) {
              _this.oplogReader.resume();
            }
            return done(err, filteredLog);
          });
        };
      })(this);
      bulkCallback = (function(_this) {
        return function(oplogs, done) {
          return _this.replication(done);
        };
      })(this);
      return this.oplogReader.start(this.lastTS, eachCallback, bulkCallback, done);
    };

    Sync.prototype.start = function(done) {
      this.logger.verbose('start', this.config);
      return this.init((function(_this) {
        return function(err) {
          return async.during(function(done) {
            return done(null, true);
          }, function(done) {
            return _this.getLastTS(function(err) {
              if (err) {
                return done(err);
              }
              return _this.sync(done);
            });
          }, function(err) {
            return _this.logger.error('error', err);
          });
        };
      })(this));
    };

    return Sync;

  })();

  module.exports = Sync;

}).call(this);
