// Generated by CoffeeScript 1.10.0
(function() {
  'use strict';
  var DEFAULT_BULK_INTERVAL, DEFAULT_BULK_LIMIT, DEFAULT_OPLOG_CURSOR_TIMEOUT, Logger, Mongo, OplogReader, _, async;

  async = require('async');

  _ = require('underscore');

  Mongo = require('./mongo');

  Logger = require('./logger');

  DEFAULT_BULK_LIMIT = 2000;

  DEFAULT_BULK_INTERVAL = 1000;

  DEFAULT_OPLOG_CURSOR_TIMEOUT = 60000;

  OplogReader = (function() {
    function OplogReader(config) {
      var base, base1;
      this.config = config;
      this.logger = new Logger(this.config.options.loglv);
      this.checkConfig();
      this.oplogConfig = _.extend({}, this.config.src, {
        database: 'local',
        collection: 'oplog.rs'
      });
      this.oplogs = [];
      (base = this.config.options).bulkLimit || (base.bulkLimit = DEFAULT_BULK_LIMIT);
      (base1 = this.config.options).bulkInterval || (base1.bulkInterval = DEFAULT_BULK_INTERVAL);
    }

    OplogReader.prototype.checkConfig = function() {
      var error;
      error = false;
      if (!this.config.name) {
        error = true;
        this.logger.error('Config error: `name` is required');
      }
      if (this.config.src.type !== 'replset') {
        error = true;
        this.logger.error('Config error: `src.type` must be `replset`');
      }
      if (error) {
        throw Error('Config error');
      }
    };

    OplogReader.prototype.init = function() {
      return this.oplogMongo = new Mongo(this.oplogConfig);
    };

    OplogReader.prototype.getTailTS = function(done) {
      return this.oplogMongo.findOne({}, {
        sort: {
          $natural: -1
        }
      }, done);
    };

    OplogReader.prototype.getQuery = function(ts, done) {
      if (ts) {
        return done(null, {
          ts: {
            $gt: ts
          }
        });
      }
      return this.getTailTS(function(err, oplog) {
        return done(null, {
          ts: {
            $gt: oplog.ts
          }
        });
      });
    };

    OplogReader.prototype.getCursor = function(ts, done) {
      return this.getQuery(ts, (function(_this) {
        return function(err, query) {
          _this.lastTS = query.ts.$gt;
          _this.logger.info('OpLog query: ', query);
          return _this.oplogMongo.find(query, {
            sort: {
              $natural: 1
            },
            tailable: true,
            awaitData: true,
            timeout: false,
            noCursorTimeout: true,
            oplogReplay: true
          }, function(err, cursor) {
            if (err) {
              return done(err);
            }
            cursor.addCursorFlag('noCursorTimeout', true);
            return done(null, cursor);
          });
        };
      })(this));
    };

    OplogReader.prototype.getTailOplogs = function(ts, done) {
      this.logger.info('getTailOplogs: ', ts);
      return this.oplogMongo.find({}, {
        sort: {
          $natural: -1
        }
      }, (function(_this) {
        return function(err, cursor) {
          var closed, oplogs, tailStream;
          if (err) {
            return done(err);
          }
          oplogs = [];
          tailStream = cursor.stream();
          closed = false;
          tailStream.on('data', function(oplog) {
            if (closed) {
              return;
            }
            if (oplog && oplog.ts > ts) {
              oplogs.push(oplog);
              return;
            }
            closed = true;
            return tailStream.close();
          });
          tailStream.on('end', function(oplog) {
            if (oplogs.length) {
              _this.lastTS = oplogs[0].ts;
            }
            return done(null, oplogs.reverse());
          });
          return tailStream.on('error', function(err) {
            return console.log('##### cursor error', err);
          });
        };
      })(this));
    };

    OplogReader.prototype.clearLogs = function() {
      var logs;
      logs = this.oplogs;
      this.oplogs = [];
      return logs;
    };

    OplogReader.prototype.resume = function() {
      if (this.stream && this.stream.connection) {
        return this.stream.resume();
      }
    };

    OplogReader.prototype.pause = function() {
      if (this.stream && this.stream.connection) {
        return this.stream.pause();
      }
    };

    OplogReader.prototype.close = function() {
      if (this.stream) {
        this.stream.close();
      }
      return this.stream = null;
    };

    OplogReader.prototype.length = function() {
      return this.oplogs.length;
    };

    OplogReader.prototype.processBulk = function(bulkCallback, done) {
      return bulkCallback(this.oplogs, (function(_this) {
        return function(err) {
          if (err) {
            _this.logger.error('Error: bulkCallback', err);
          }
          _this.clearLogs();
          _this.resume();
          return typeof done === "function" ? done(err) : void 0;
        };
      })(this));
    };

    OplogReader.prototype.start = function(ts, eachCallback, bulkCallback, done) {
      return this.run(ts, eachCallback, bulkCallback, (function(_this) {
        return function(err) {
          clearInterval(_this.tailOplogInterval);
          _this.tailOplogInterval = null;
          clearInterval(_this.bulkInterval);
          _this.bulkInterval = null;
          _this.close();
          return done(err);
        };
      })(this));
    };

    OplogReader.prototype.run = function(ts, eachCallback, bulkCallback, done) {
      var doneCalled;
      doneCalled = false;
      this.clearLogs();
      return this.getCursor(ts, (function(_this) {
        return function(err, cursor) {
          if (err) {
            done(err);
          }
          _this.stream = cursor.stream();
          _this.lastDataTime = null;
          _this.lastBulkCallbackTime = null;
          if (_this.tailOplogInterval) {
            clearInterval(_this.tailOplogInterval);
          }
          _this.tailOplogInterval = setInterval(function() {
            if (_this.tailOplogIntervalProcessing) {
              _this.logger.error('Delay tailOplogInterval');
              return;
            }
            _this.tailOplogIntervalProcessing = true;
            if (_this.lastDataTime) {
              clearInterval(_this.tailOplogInterval);
              return;
            }
            _this.pause();
            return _this.getTailOplogs(_this.lastTS, function(err, oplogs) {
              if (err) {
                _this.logger.error('Error: getTailOplogs', err);
                _this.resume();
                return done(err);
              }
              return async.eachSeries(oplogs, function(oplog, done) {
                return eachCallback(oplog, function(err, filteredLog) {
                  if (err) {
                    return done(err);
                  }
                  if (filteredLog) {
                    _this.oplogs.push(filteredLog);
                  }
                  return done(null);
                });
              }, function(err) {
                if (err) {
                  _this.logger.error('Error: eachSeries', err);
                }
                _this.resume();
                return _this.tailOplogIntervalProcessing = false;
              });
            });
          }, 1000);
          if (_this.bulkInterval) {
            clearInterval(_this.bulkInterval);
          }
          _this.bulkIntervalProcessing = false;
          _this.bulkInterval = setInterval(function() {
            var now;
            if (_this.bulkIntervalProcessing) {
              _this.logger.error('Delay bulkInterval');
              return;
            }
            _this.bulkIntervalProcessing = true;
            now = Date.now();
            if (_this.lastDataTime && (now - _this.lastDataTime) > _this.config.options.oplogCursorTimeout) {
              _this.logger.error('Cursor broken ?');
              _this.close();
              if (!doneCalled) {
                doneCalled = true;
                done(null);
              }
              return;
            }
            if (_this.oplogs.length && (!_this.lastBulkCallbackTime || (now - _this.lastBulkCallbackTime) >= _this.config.options.bulkInterval || _this.oplogs.length >= _this.config.options.bulkLimit)) {
              _this.lastBulkCallbackTime = now;
              _this.pause();
              return _this.processBulk(bulkCallback, function(err) {
                return _this.bulkIntervalProcessing = false;
              });
            } else {
              return _this.bulkIntervalProcessing = false;
            }
          }, _this.config.options.bulkInterval / 10);
          _this.stream.on('data', function(oplog) {
            _this.lastDataTime = Date.now();
            if (_this.lastTS >= oplog.ts) {
              return;
            }
            _this.lastTS = oplog.ts;
            _this.pause();
            return eachCallback(oplog, function(err, filteredLog) {
              if (err) {
                _this.logger.error('Error: eachCallback', err);
                _this.resume();
                return;
              }
              if (filteredLog) {
                _this.oplogs.push(filteredLog);
              }
              if (_this.oplogs.length >= _this.config.options.bulkLimit) {
                _this.lastBulkCallbackTime = _this.lastDataTime;
                return bulkCallback(_this.oplogs, function(err) {
                  if (err) {
                    _this.logger.error('Error: bulkCallback', err);
                  }
                  _this.clearLogs();
                  _this.resume();
                });
              } else {
                return _this.resume();
              }
            });
          });
          _this.stream.on('end', function() {
            if (!doneCalled) {
              _this.logger.error('Cursor closed');
              doneCalled = true;
              _this.close();
              return done(null);
            }
          });
          return _this.stream.on('error', function() {
            return console.log('stream error');
          });
        };
      })(this));
    };

    return OplogReader;

  })();

  module.exports = OplogReader;

}).call(this);
